.
├── LICENSE (MIT License

Copyright (c) 2025 VARCAVIA Inc

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
)
├── Makefile (# ==============================================================================
# Makefile Unificato e Potenziato per il progetto VARCAVIA Office
#
# Questo file centralizza tutti i comandi comuni per lo sviluppo e il deployment,
# combinando la qualità del codice Go con il ciclo di vita completo per
# Protobuf, Docker e Kubernetes.
# ==============================================================================

# ----------------- Variabili di Configurazione -----------------
# Modifica questi valori per i futuri servizi.
IMAGE_NAME := varcavia/state-aggregator
IMAGE_TAG  := v0.1.0


# ----------------- Qualità del Codice & Dipendenze -----------------

## lint: Formatta e controlla la qualità del codice Go (go fmt, go vet).
.PHONY: lint
lint:
	@echo ">> Linting Go files..."
	@go fmt ./...
	@go vet ./...

## tidy: Pulisce e sistema le dipendenze del modulo Go.
.PHONY: tidy
tidy:
	@echo ">> Tidying Go module dependencies..."
	@go mod tidy


# ----------------- Generazione Codice Protobuf -----------------

## proto: Genera il codice Go dagli schemi Protobuf utilizzando buf.
.PHONY: proto
proto:
	@echo ">> Generating Protobuf Go code..."
	@cd schemas && buf generate && cd ..
	@echo "✅ Protobuf code generated successfully."


# ----------------- Ciclo di Vita Docker -----------------

## build: Costruisce l'immagine Docker per il state_aggregator_service.
.PHONY: build
build:
	@echo ">> Building Docker image: $(IMAGE_NAME):$(IMAGE_TAG)..."
	@docker build -t $(IMAGE_NAME):$(IMAGE_TAG) -f services/state_aggregator/Dockerfile .
	@echo "✅ Docker image built successfully."


# ----------------- Ciclo di Vita Kubernetes -----------------

## deploy: Applica i manifest Kubernetes per il state_aggregator.
.PHONY: deploy
deploy:
	@echo ">> Deploying state_aggregator to Kubernetes..."
	@kubectl apply -f k8s/state-aggregator-service.yaml
	@kubectl apply -f k8s/state-aggregator-deployment.yaml
	@echo "✅ Service deployed. Run 'kubectl get pods' to check status."

## undeploy: Rimuove le risorse del state_aggregator da Kubernetes.
.PHONY: undeploy
undeploy:
	@echo ">> Removing state_aggregator from Kubernetes..."
	@kubectl delete -f k8s/state-aggregator-deployment.yaml --ignore-not-found=true
	@kubectl delete -f k8s/state-aggregator-service.yaml --ignore-not-found=true
	@echo "✅ Service undeployed."


# ----------------- Aiuto -----------------

## help: Mostra questo messaggio di aiuto auto-documentante.
.PHONY: help
help:
	@echo "Usage: make <target>"
	@echo ""
	@echo "Available targets:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

)
├── README.md (# VARCAVIA Office - Organismo Digitale Autonomo

Questo repository contiene il codice sorgente e l'infrastruttura per **VARCAVIA Office**, un organismo digitale autonomo progettato per eseguire missioni di business complesse con intelligenza, efficienza e capacità di auto-miglioramento.

## Visione

[cite_start]Creare la prima piattaforma al mondo di organismi digitali autonomi, capaci di eseguire missioni di business complesse con un'intelligenza e un'efficienza sovrumane. [cite: 194]

## Architettura di Riferimento

Il sistema è progettato come un'architettura di microservizi event-driven, orchestrata su Kubernetes.

* [cite_start]**Livello di Orchestrazione:** Kubernetes (GKE) [cite: 206]
* [cite_start]**Livello di Comunicazione:** Apache Kafka come spina dorsale asincrona [cite: 207]
* [cite_start]**Livello di Rete e Sicurezza:** Istio service mesh con policy mTLS STRICT [cite: 208]
* [cite_start]**Livello di Intelligenza:** Google Gemini 1.5 Pro e modelli di sicurezza dedicati [cite: 209, 210]
* [cite_start]**Livello Dati:** Neo4j (memoria a lungo termine) e Redis (stato volatile) [cite: 212, 211]
* **Stack di Sviluppo:** I servizi core sono sviluppati in **Go**.

## Servizi Chiave

* **ceo_service:** Il cervello strategico, traduce la missione in obiettivi.
* **architect_service:** Il progettista tattico, crea piani tecnici (blueprint).
* **worker_pool:** Il braccio esecutivo, esegue i task atomici.
* **auditor_service:** La coscienza etica e di sicurezza.
* **knowledge_graph_populator:** Popola la memoria a lungo termine.
* **cost_optimizer_service:** Gestisce proattivamente i costi cloud.

Questo progetto è gestito seguendo il piano esecutivo dettagliato "VARCAVIA Office - PIANO 4.0".)
├── build ()
│   └── package
├── dna
│   └── business_mission.yaml (missionID: "MISSION-2025-Q3-001"
version: "1.0.0"
marketContext:
  [cite_start]targetMarketSegment: "PMI nel settore e-commerce e SaaS B2B [cite: 196]"
  [cite_start]competitiveAdvantage: "Offrire intelligenza strategica autonoma as-a-service, non semplice automazione [cite: 198]"
[cite_start]description: "Validare il primo ciclo vitale autonomo (MVP) del sistema VARCAVIA Office, eseguendo un task semplice dall'inizio alla fine per dimostrare la funzionalità della catena ceo_service -> architect_service -> worker_pool[cite: 220]."
kpis:
  - name: "End-to-End Task Success Rate"
    target: "100%"
    query: "COUNT(tasks_successful) / COUNT(tasks_created)"
  - name: "Cycle Time"
    target: "< 10 minutes"
    query: "AVG(task_completion_timestamp - task_creation_timestamp)"
constraints:
  budget:
    [cite_start]monthlyAmountEUR: 2300 # Budget per la Fase 1 [cite: 227]
    currency: "EUR")
├── go.mod (module varcavia.com/sentient-organism

go 1.24.5

require (
	golang.org/x/net v0.22.0 // indirect
	golang.org/x/sys v0.18.0 // indirect
	golang.org/x/text v0.14.0 // indirect
	google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 // indirect
	google.golang.org/grpc v1.64.0 // indirect
	google.golang.org/protobuf v1.33.0 // indirect
)

replace varcavia.com/sentient-organism => ./
)
├── go.sum (golang.org/x/net v0.22.0 h1:9sGLhx7iRIHEiX0oAJ3MRZMUCElJgy7Br1nO+AMN3Tc=
golang.org/x/net v0.22.0/go.mod h1:JKghWKKOSdJwpW2GEx0Ja7fmaKnMsbu+MWVZTokSYmg=
golang.org/x/sys v0.18.0 h1:DBdB3niSjOA/O0blCZBqDefyWNYveAYMNF1Wum0DYQ4=
golang.org/x/sys v0.18.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/text v0.14.0 h1:ScX5w1eTa3QqT8oi6+ziP7dTV1S2+ALU0bI+0zXKWiQ=
golang.org/x/text v0.14.0/go.mod h1:18ZOQIKpY8NJVqYksKHtTdi31H5itFRjB5/qKTNYzSU=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 h1:NnYq6UN9ReLM9/Y01KWNOWyI5xQ9kbIms5GGJVwS/Yc=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237/go.mod h1:WtryC6hu0hhx87FDGxWCDptyssuo68sk10vYjF+T9fY=
google.golang.org/grpc v1.64.0 h1:KH3VH9y/MgNQg1dE7b3XfVK0GsPSIzJwdF617gUSbvY=
google.golang.org/grpc v1.64.0/go.mod h1:oxjF8E3FBnjp+/gVFYdWacaLDx9na1aqy9oovLpxQYg=
google.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=
google.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
)
├── k8s
│   ├── state-aggregator-deployment.yaml (apiVersion: apps/v1
kind: Deployment
metadata:
  name: state-aggregator-deployment
  # È buona norma aggiungere etichette per l'organizzazione
  labels:
    app: state-aggregator
spec:
  replicas: 1 # Iniziamo con una singola istanza
  selector:
    matchLabels:
      app: state-aggregator
  template:
    metadata:
      labels:
        app: state-aggregator
    spec:
      containers:
        - name: state-aggregator
          # Sostituisci questo con il nome dell'immagine che costruirai
          image: varcavia/state-aggregator:v0.1.0
          imagePullPolicy: IfNotPresent # Usa l'immagine locale se disponibile
          ports:
            - containerPort: 50051 # La porta gRPC che abbiamo esposto
          env:
            - name: REDIS_ADDR
              # Questo valore verrà preso da un ConfigMap o da un Secret in un ambiente di produzione.
              # Per ora, usiamo un indirizzo hardcoded che punta al servizio Redis.
              value: "redis-service:6379"
          # 'probes' per la salute del servizio, come da piano
          livenessProbe:
            tcpSocket:
              port: 50051
            initialDelaySeconds: 15
            periodSeconds: 20
          readinessProbe:
            tcpSocket:
              port: 50051
            initialDelaySeconds: 5
            periodSeconds: 10
          # Limiti di risorse per garantire la stabilità del cluster
          resources:
            requests:
              cpu: "100m" # 0.1 core
              memory: "64Mi"
            limits:
              cpu: "200m" # 0.2 core
              memory: "128Mi"

)
│   └── state-aggregator-service.yaml (apiVersion: v1
kind: Service
metadata:
  name: state-aggregator-service
spec:
  # Il tipo ClusterIP espone il servizio solo all'interno del cluster.
  type: ClusterIP
  selector:
    # Seleziona i pod che hanno l'etichetta 'app: state-aggregator'
    app: state-aggregator
  ports:
    - protocol: TCP
      port: 50051 # La porta su cui il servizio è esposto
      targetPort: 50051 # La porta del container a cui inoltrare il traffico
)
├── manifests
│   └── base
├── project_overview.txt (.
├── LICENSE
├── Makefile
├── README.md
├── build
│   └── package
├── dna
│   └── business_mission.yaml
├── go.mod
├── go.sum
├── k8s
│   ├── state-aggregator-deployment.yaml
│   └── state-aggregator-service.yaml
├── manifests
│   └── base
├── project_overview.txt
├── project_structure.txt
├── schemas
│   ├── buf.gen.yaml
│   ├── buf.yaml
│   ├── dna_schema.json
│   ├── services
│   │   └── gen
│   └── v1
│       └── state_aggregator.proto
├── scripts
│   └── vertex_check.sh
├── services
│   ├── internal
│   │   └── config
│   └── state_aggregator
│       └── main.go
└── workflow_structure.txt

16 directories, 17 files
)
├── project_structure.txt (# Struttura del Progetto e Contenuto dei File
/
build/
build/package/
schemas/
schemas/v1/
schemas/services/
schemas/services/gen/
schemas/services/gen/go/
schemas/services/gen/go/services/
schemas/services/gen/go/services/gen/
schemas/services/gen/go/services/gen/go/
schemas/services/gen/go/services/gen/go/state_aggregator/
schemas/services/gen/go/services/gen/go/state_aggregator/v1/
services/
services/state_aggregator/
services/internal/
services/internal/config/
scripts/
k8s/
manifests/
manifests/base/
dna/
./Makefile
  

./schemas/v1/state_aggregator.proto
  

./schemas/services/gen/go/services/gen/go/state_aggregator/v1/state_aggregator_grpc.pb.go
  

./schemas/services/gen/go/services/gen/go/state_aggregator/v1/state_aggregator.pb.go
  

./schemas/buf.yaml
  

./schemas/dna_schema.json
  

./schemas/buf.gen.yaml
  

./README.md
  

./go.mod
  

./go.sum
  

./services/state_aggregator/main.go
  

./services/internal/config/dna_loader.go
  

./scripts/vertex_check.sh
  

./PROJECT_BRIEF.md
  

./k8s/state-aggregator-service.yaml
  

./k8s/state-aggregator-deployment.yaml
  

./dna/business_mission.yaml
  

./workflow_structure.txt
  

./LICENSE
  

./project_structure.txt
  


# Fine della struttura
)
├── schemas
│   ├── buf.gen.yaml (# schemas/buf.gen.yaml
# Versione corretta: abbiamo rimosso &#39;paths=source_relative&#39; per dare pieno
# controllo all&#39;opzione &#39;go_package&#39; definita nei file .proto.
version: v1
plugins:
  - plugin: go
    out: services/gen/go
  - plugin: go-grpc
    out: services/gen/go)
│   ├── buf.yaml (    # schemas/buf.yaml
    # Definisce la root del nostro modulo Protobuf e le sue dipendenze.
    version: v1
    name: buf.build/varcavia/sentient-organism
    deps:
      - buf.build/googleapis/googleapis
    breaking:
      use:
        - FILE
    lint:
      use:
        - DEFAULT
    )
│   ├── dna_schema.json ({
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "Schema per la validazione di business_mission.yaml",
  "type": "object",
  "required": [
    "missionID",
    "version",
    "marketContext",
    "description",
    "kpis",
    "constraints"
  ],
  "properties": {
    "missionID": {
      "type": "string",
      "pattern": "^MISSION-[0-9]{4}-Q[1-4]-[0-9]{3}$"
    },
    "version": {
      "type": "string",
      "pattern": "^[0-9]+\\.[0-9]+\\.[0-9]+$"
    },
    "marketContext": {
      "type": "object",
      "required": ["targetMarketSegment", "competitiveAdvantage"],
      "properties": {
        "targetMarketSegment": { "type": "string", "minLength": 10 },
        "competitiveAdvantage": { "type": "string", "minLength": 10 }
      }
    },
    "description": {
      "type": "string",
      "minLength": 20
    },
    "kpis": {
      "type": "array",
      "minItems": 1,
      "items": {
        "type": "object",
        "required": ["name", "target", "query"],
        "properties": {
          "name": { "type": "string" },
          "target": { "type": "string" },
          "query": { "type": "string" }
        }
      }
    },
    "constraints": {
      "type": "object",
      "required": ["budget"],
      "properties": {
        "budget": {
          "type": "object",
          "required": ["monthlyAmountEUR", "currency"],
          "properties": {
            "monthlyAmountEUR": { "type": "integer", "minimum": 1 },
            "currency": { "type": "string", "enum": ["EUR"] }
          }
        }
      }
    }
  }
})
│   ├── services 
│   │   └── gen
│   └── v1
│       └── state_aggregator.proto (// /schemas/v1/state_aggregator.proto
syntax = "proto3";

// Il package definisce un namespace per evitare collisioni e organizza gli schemi.
package varcavia.state_aggregator.v1;

// Opzione specifica per Go: indica al compilatore dove posizionare il codice generato.
option go_package = "services/gen/go/state_aggregator/v1;state_aggregator_v1";

import "google/protobuf/timestamp.proto";

// Enum per definire un set controllato di stati possibili per un task.
// Questo previene errori di battitura e garantisce consistenza nel sistema.
enum Status {
  STATUS_UNSPECIFIED = 0;
  PENDING = 1;
  IN_PROGRESS = 2;
  COMPLETED_SUCCESS = 3;
  COMPLETED_FAILURE = 4;
}

// TaskState rappresenta la fotografia dello stato di un singolo task in un dato momento.
message TaskState {
  string task_id = 1; // ID univoco del task, funge da chiave primaria.
  Status status = 2; // Lo stato corrente del task.
  string worker_id = 3; // ID del worker che sta eseguendo o ha eseguito il task.
  google.protobuf.Timestamp last_update = 4; // Timestamp dell'ultimo aggiornamento di stato.
  string details = 5; // Campo opzionale per log di errore o metadati aggiuntivi.
}

// Definisce il servizio gRPC StateAggregator e i suoi metodi (RPCs).
service StateAggregatorService {
  // Imposta (crea o aggiorna) lo stato di un task.
  rpc SetTaskState(SetTaskStateRequest) returns (SetTaskStateResponse);
  // Recupera lo stato corrente di un task.
  rpc GetTaskState(GetTaskStateRequest) returns (GetTaskStateResponse);
}

// Messaggi per la RPC SetTaskState
message SetTaskStateRequest {
  TaskState state = 1; // L'oggetto di stato completo da salvare.
}

message SetTaskStateResponse {
  bool success = 1; // Restituisce true se l'operazione ha avuto successo.
  string task_id = 2; // Restituisce l'ID del task per conferma.
}

// Messaggi per la RPC GetTaskState
message GetTaskStateRequest {
  string task_id = 1; // L'ID del task da recuperare.
}

message GetTaskStateResponse {
  TaskState state = 1; // Lo stato del task recuperato.
}
)
├── scripts
│   └── vertex_check.sh (#!/usr/bin/env bash
set -euo pipefail

echo "=== Vertex AI Project Profile ==="
echo "Active gcloud account : $(gcloud config get-value account)"
echo "Active project        : $(gcloud config get-value project)"
echo "Impersonated SA       : $(gcloud config get-value auth/impersonate_service_account)"
echo ""

echo "=== Enabled APIs ==="
gcloud services list --enabled \
  --filter="aiplatform.googleapis.com OR iam.googleapis.com OR iamcredentials.googleapis.com" \
  --format="value(config.name)"
echo ""

echo "=== ADC Quota Project Check ==="
ADC_FILE=${GOOGLE_APPLICATION_CREDENTIALS:-$HOME/.config/gcloud/application_default_credentials.json}
if [[ -f "$ADC_FILE" ]]; then
  python3 - <<PY
import json, os
with open("$ADC_FILE") as f:
    d=json.load(f)
print("ADC quota_project_id :", d.get("quota_project_id", "not set"))
PY
else
  echo "ADC file not found"
fi
echo ""

echo "=== Available Gemini models (us-central1) ==="
curl -s -H "Authorization: Bearer $(gcloud auth print-access-token)" \
  "https://us-central1-aiplatform.googleapis.com/v1/projects/$(gcloud config get-value project)/locations/us-central1/publishers/google/models" \
  | grep -E '"displayName":.*gemini' || true
echo ""

echo "=== Live Haiku Test (gemini‑2.5‑flash) ==="
curl -s -X POST \
  -H "Authorization: Bearer $(gcloud auth print-access-token)" \
  -H "Content-Type: application/json" \
  "https://us-central1-aiplatform.googleapis.com/v1/projects/$(gcloud config get-value project)/locations/us-central1/publishers/google/models/gemini-2.5-flash:generateContent" \
  -d '{"contents":[{"role":"user","parts":[{"text":"Scrivi un haiku sul codice che finalmente funziona"}]}]}' \
  | python3 -c "import json,sys;print(json.load(sys.stdin)['candidates'][0]['content']['parts'][0]['text'].strip())"
echo ""
echo "=== Done ==="
)
├── services
│   ├── internal
│   │   └── config (package config

// BusinessMission corrisponde alla struttura di business_mission.yaml e funge da modello per il DNA dell'organismo.
type BusinessMission struct {
	MissionID   string        `yaml:"missionID"`
	Version     string        `yaml:"version"`
	MarketContext MarketContext `yaml:"marketContext"`
	Description string        `yaml:"description"`
	KPIs        []KPI         `yaml:"kpis"`
	Constraints Constraints   `yaml:"constraints"`
}

// MarketContext definisce il contesto di mercato in cui opera la missione.
type MarketContext struct {
	TargetMarketSegment string `yaml:"targetMarketSegment"`
	CompetitiveAdvantage string `yaml:"competitiveAdvantage"`
}

// KPI (Key Performance Indicator) definisce una metrica di successo per la missione.
type KPI struct {
	Name   string `yaml:"name"`
	Target string `yaml:"target"`
	Query  string `yaml:"query"`
}

// Constraints definisce i limiti operativi e di budget per la missione.
type Constraints struct {
	Budget Budget `yaml:"budget"`
}

// Budget specifica i vincoli finanziari.
type Budget struct {
	MonthlyAmountEUR int    `yaml:"monthlyAmountEUR"`
	Currency         string `yaml:"currency"`
})
│   └── state_aggregator
│       └── main.go (package main

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"time"

	"github.com/redis/go-redis/v9"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	// Importa il package Go generato da Protobuf.
	// Assicurati che il percorso corrisponda a quello nel tuo go.mod.
	pb "varcavia.com/sentient-organism/services/gen/go/state_aggregator/v1"
)

// server struct implementa l'interfaccia gRPC generata.
// Contiene un client Redis per interagire con il database.
type server struct {
	pb.UnimplementedStateAggregatorServiceServer // Necessario per la compatibilità futura.
	redisClient *redis.Client
}

// NewServer crea una nuova istanza del nostro server con un client Redis configurato.
func NewServer() *server {
	redisAddr := os.Getenv("REDIS_ADDR")
	if redisAddr == "" {
		redisAddr = "localhost:6379" // Fallback per lo sviluppo locale.
	}

	rdb := redis.NewClient(&redis.Options{
		Addr: redisAddr,
	})

	// Testa la connessione a Redis all'avvio.
	if _, err := rdb.Ping(context.Background()).Result(); err != nil {
		log.Fatalf("Impossibile connettersi a Redis: %v", err)
	}

	log.Printf("Connessione a Redis stabilita con successo a %s", redisAddr)
	return &server{redisClient: rdb}
}

// SetTaskState implementa la logica per salvare lo stato di un task in Redis.
func (s *server) SetTaskState(ctx context.Context, req *pb.SetTaskStateRequest) (*pb.SetTaskStateResponse, error) {
	state := req.GetState()
	if state == nil || state.TaskId == "" {
		return nil, status.Error(codes.InvalidArgument, "L'oggetto State o il TaskId non possono essere vuoti")
	}

	key := fmt.Sprintf("task_state:%s", state.TaskId)

	// Utilizziamo una pipeline per eseguire i comandi HSet e Expire in modo atomico.
	// Questo garantisce che lo stato venga sempre salvato con la sua data di scadenza.
	pipe := s.redisClient.TxPipeline()
	pipe.HSet(ctx, key, map[string]interface{}{
		"status":      state.Status.String(),
		"worker_id":   state.WorkerId,
		"last_update": time.Now().UTC().Format(time.RFC3339),
		"details":     state.Details,
	})
	pipe.Expire(ctx, key, 24*time.Hour) // Imposta una TTL di 24 ore per pulizia automatica.

	if _, err := pipe.Exec(ctx); err != nil {
		log.Printf("Errore durante l'aggiornamento dello stato su Redis per il task %s: %v", state.TaskId, err)
		return nil, status.Error(codes.Internal, "Impossibile aggiornare lo stato nel database")
	}

	return &pb.SetTaskStateResponse{Success: true, TaskId: state.TaskId}, nil
}

// GetTaskState implementa la logica per recuperare lo stato di un task da Redis.
func (s *server) GetTaskState(ctx context.Context, req *pb.GetTaskStateRequest) (*pb.GetTaskStateResponse, error) {
	taskID := req.GetTaskId()
	if taskID == "" {
		return nil, status.Error(codes.InvalidArgument, "Il TaskId non può essere vuoto")
	}

	key := fmt.Sprintf("task_state:%s", taskID)
	val, err := s.redisClient.HGetAll(ctx, key).Result()

	if err != nil {
		// Se la chiave non viene trovata, redis.Nil è l'errore restituito.
		// In questo caso, restituiamo un errore gRPC standard "NotFound".
		if err == redis.Nil {
			return nil, status.Errorf(codes.NotFound, "Nessuno stato trovato per il task ID: %s", taskID)
		}
		log.Printf("Errore durante il recupero dello stato da Redis per il task %s: %v", taskID, err)
		return nil, status.Error(codes.Internal, "Impossibile recuperare lo stato dal database")
	}

	// Converte lo stato da stringa all'enum Protobuf.
	statusVal, ok := pb.Status_value[val["status"]]
	if !ok {
		return nil, status.Error(codes.Internal, "Stato non valido recuperato dal database")
	}

	return &pb.GetTaskStateResponse{
		State: &pb.TaskState{
			TaskId:   taskID,
			Status:   pb.Status(statusVal),
			WorkerId: val["worker_id"],
			Details:  val["details"],
			// La conversione del timestamp non è inclusa per semplicità, ma andrebbe gestita.
		},
	}, nil
}

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "50051" // Porta di default per gRPC.
	}

	lis, err := net.Listen("tcp", fmt.Sprintf(":%s", port))
	if err != nil {
		log.Fatalf("Impossibile mettersi in ascolto sulla porta %s: %v", port, err)
	}

	s := grpc.NewServer()
	pb.RegisterStateAggregatorServiceServer(s, NewServer())

	log.Printf("✅ Server gRPC in ascolto su %v", lis.Addr())
	if err := s.Serve(lis); err != nil {
		log.Fatalf("Impossibile avviare il server: %v", err)
	}
}
)
└── workflow_structure.txt (.github/workflows/1_manager_bot.yml (name: 1. Manager Bot Orchestration

on:
  push:
    branches: [ main ]
    paths:
      - 'src/business_plan.yaml'
  
  workflow_dispatch:

  workflow_run:
    workflows: ["4. PR Validation"]
    types:
      - completed

jobs:
  run_manager_bot:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      actions: write 
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with: { token: '${{ secrets.BOT_GITHUB_TOKEN }}' }
      
      - uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/826570341026/locations/global/workloadIdentityPools/varcavia-github-pool/providers/varcavia-github-provider'
          service_account: 'vertex-client@varcavia-office-bc6xvv.iam.gserviceaccount.com'

      - uses: actions/setup-python@v5
        with: { python-version: '3.9' }

      - name: Install Dependencies & Run
        env:
          GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          GCP_PROJECT: 'varcavia-office-bc6xvv'
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pip install -r requirements.txt
          gh auth setup-git
          python src/bots/manager_bot.py)
.github/workflows/4_validation.yml (name: 4. PR Validation

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  validate-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      id-token: write
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4

      - name: 'Authenticate to Google Cloud'
        uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/826570341026/locations/global/workloadIdentityPools/varcavia-github-pool/providers/varcavia-github-provider'
          service_account: 'vertex-client@varcavia-office-bc6xvv.iam.gserviceaccount.com'

      - name: Set up Python
        uses: actions/setup-python@v5
        with: { python-version: '3.9' }

      - name: Install Dependencies
        run: pip install -r requirements.txt
      
      - name: Add CI Status Label
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          gh pr edit $PR_NUMBER --add-label "status: ci-in-progress"

      - name: Run Unit Tests
        id: tests
        run: pytest

      - name: Update PR Status Based on Tests
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        if: always()
        run: |
          gh pr edit $PR_NUMBER --remove-label "status: ci-in-progress"
          if [[ ${{ steps.tests.outcome }} == 'success' ]]; then
            gh pr edit $PR_NUMBER --add-label "ci: passed"
          else
            gh pr edit $PR_NUMBER --add-label "ci: failed"
            exit 1
          fi)
.github/workflows/2_operator_bot.yml (name: 2. Operator Bot Task Execution

on:
  workflow_dispatch:
    inputs:
      branch_name: { required: true }
      task_description: { required: true }
      task_line_index: { required: true }

jobs:
  execute_task:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      id-token: write
    steps:
      - uses: actions/checkout@v4
        with: { token: '${{ secrets.BOT_GITHUB_TOKEN }}' }

      - uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/826570341026/locations/global/workloadIdentityPools/varcavia-github-pool/providers/varcavia-github-provider'
          service_account: 'vertex-client@varcavia-office-bc6xvv.iam.gserviceaccount.com'

      - uses: actions/setup-python@v5
        with: { python-version: '3.9' }

      - name: Install Dependencies & Run
        env:
          BRANCH_NAME: ${{ github.event.inputs.branch_name }}
          TASK_DESCRIPTION: ${{ github.event.inputs.task_description }}
          TASK_LINE_INDEX: ${{ github.event.inputs.task_line_index }}
          GITHUB_TOKEN: ${{ secrets.BOT_GITHUB_TOKEN }}
          GCP_PROJECT: 'varcavia-office-bc6xvv'
          PYTHONPATH: ${{ github.workspace }}
        run: |
          pip install -r requirements.txt
          gh auth setup-git
          python src/bots/operator_bot.py)
.github/workflows/3_audit_bot.yml (name: 3. Audit Bot Supervision

on:
  workflow_dispatch:
  schedule:
    - cron: '0 3 * * *' # Ogni notte alle 3

jobs:
  run_audit_bot:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: read 
      id-token: write
    steps:
      - uses: actions/checkout@v4

      - uses: 'google-github-actions/auth@v2'
        with:
          workload_identity_provider: 'projects/826570341026/locations/global/workloadIdentityPools/varcavia-github-pool/providers/varcavia-github-provider'
          service_account: 'vertex-client@varcavia-office-bc6xvv.iam.gserviceaccount.com'

      - uses: actions/setup-python@v5
        with: { python-version: '3.9' }

      - name: Install Dependencies & Run
        env:
          GCP_PROJECT: 'varcavia-office-bc6xvv'
          PYTHONPATH: ${{ github.workspace }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_PORT: ${{ secrets.EMAIL_PORT }}
          EMAIL_USERNAME: ${{ secrets.EMAIL_USERNAME }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          SENDER_EMAIL: ${{ secrets.SENDER_EMAIL }}
          RECEIVER_EMAIL: ${{ secrets.RECEIVER_EMAIL }}
        run: |
          pip install -r requirements.txt
          gh auth setup-git
          python src/bots/audit_bot.py)
)

16 directories, 17 files
